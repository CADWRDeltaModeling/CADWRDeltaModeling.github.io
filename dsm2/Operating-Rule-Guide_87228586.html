<!DOCTYPE html>
<html>
    <head>
        <title>DSM2 version 8.2 : Operating Rule Guide</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="index.html">DSM2 version 8.2</a></span>
                            </li>
                                                    <li>
                                <span><a href="DSM2_87228545.html">DSM2</a></span>
                            </li>
                                                    <li>
                                <span><a href="Documentation_87228546.html">Documentation</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            DSM2 version 8.2 : Operating Rule Guide
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                        
        
    
        
    
        
        
            Created by <span class='author'> Nicky Sandhu</span> on Jan 27, 2021
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <h1 id="OperatingRuleGuide-OperatingRuleGuide">Operating Rule Guide</h1><h2 id="OperatingRuleGuide-Introduction">Introduction</h2><p>DSM2 uses a text language for operating rules, and the rules are stored in the database. Operating rules combine trigger and action directives, each of which is an expression based on observed model states, seasonal information and exogenous time series input as well as other expressions.</p><p>Actions are things the operating rule does. In DSM2-DB, the actions affect either gate devices or source/sink flow boundaries. For gate devices the operating flow coefficient can be changed. For sources and sinks, flow may be set to a new constant value or a new time series. Expressions for actions tend to be of the form:</p><pre>SET model_object TO numerical_expression</pre><p>The action becomes applicable when a corresponding trigger goes from false to true. Triggers are written with expressions that evaluate true or false:</p><pre>chan_stage(channel=132, dist=1000) &lt; -0.1</pre><p>Some rules are immediate responses to model conditions (close the gate when stage dips below 0.5). Other rules use triggers to describe seasons or situations where the action is applicable (reduce a boundary flow when the month is between May and September). Still others rules apply from the beginning of the run and the trigger column is just a nuisance –.</p><h2 id="OperatingRuleGuide-Expressions">Expressions</h2><p>An expression is just a named quantity that is derived from model data, outside time series data, math and time functions. An example of a simple numerical expression based on current DSM2-DB flow looks like this:</p><pre>ebb := chan_flow(channel=132, dist=1000) &gt; 0.01</pre><p>This example samples the current time step model flow 1,000 ft downstream of the upstream node in channel 132 and checks whether it is greater than 0.01 cfs. The expression assigns the answer the name ebb, so it can be reused in later expressions. Note that ebb is a logical expression which evaluates to true or false depending on the model time step. Numerical expressions will be introduced shortly.</p><p>Assignments of named expressions always start with a name the assignment operator “:=”. Spaces around the assignment and greater-than operators are optional. The assignment operator isn’t actually used in the GUI, because there is a separate column for the name and definition.</p><p>The chan_flow part of the expression represents the value of a model variable. Model variables typically require identifiers, which are included in parenthesis and are a comma-separated list with elements that depend on the context (see the section below on DSM2 model variable identifiers). These identifiers can be numerical or text strings:</p><pre>chan_flow(channel=132, dist=1000) ...numerical</pre><pre>gate_op(gate=middle_river_barrier, device=weir) ...strings</pre><p>The examples thus far have been logical expressions. Logical expressions usually appear in triggers rather than actions. Besides logical expressions, expressions that evaluate to numerical values can be defined:</p><pre>ebbmagnitude := log(chan_flow(channel=132, dist=1000))</pre><p>and expressions can also involve simple math operators. For instance:</p><pre>ebbmagnitude := log(chan_flow(channel=132, dist=1000))</pre><p>is an expression that evaluates flow, applies the log function to it and then assigns it to the variable name ebbmagnitude. For details, see the section below on Math Operators)</p><p>Model time can also be used in expressions. The following expression describes the VAMP season for San Joaquin river management:</p><pre>vamp := (MONTH == APR) or (MONTH == MAY)</pre><p>The definition could also include the date, day of the month, or time of day.</p><p>month, or time of day.<br/>Finally, the following example combines a model state (stage/water surface) observation, an external time series (called tide_level) and some simple arithmetic. The expression might be used with a slowly fluctuating tide or sea level datum to provide an idea of critical stage in the South Delta compared to ambient tide conditions.</p><pre>critical_stage := chan_stage(channel=132,dist=1000)&lt;(tide_level-1.0)</pre><h2 id="OperatingRuleGuide-OperatingRules">Operating Rules</h2><p>It is now straightforward to use expressions in operating rules. The following example is based on expressions that were developed above. <strong>Bold face</strong> words correspond to tables or columns of the GUI.</p><h3 id="OperatingRuleGuide-Name">Name</h3><pre>middle_vamp_ebb</pre><h3 id="OperatingRuleGuide-Expressions.1">Expressions</h3><pre>ebb := chan_flow(channel=132, dist=1000) &gt; 0.01<br/>vamp := (month == Apr) OR (month == May)</pre><h3 id="OperatingRuleGuide-Trigger">Trigger</h3><pre>vamp AND ebb</pre><h3 id="OperatingRuleGuide-Action">Action</h3><pre>SET gate_op(gate=middle_river_barrier, device=weir) TO ts(new_time_series)</pre><p><br/></p><p>The <em>middle_vamp_ebb</em> operating rule lies dormant until the first time step when vamp and ebb (a compound expression based on the expressions <strong>vamp</strong> and <strong>ebb</strong>) becomes true. At that point the action will be taken and the weir operating coefficient will start to operate according to the values in the DSS time series new_time_series. Note that except for the expression definitions, the parts of this operating rule can be united using the name assignment (:=) and WHERE directives:</p><pre>middle_vamp_ebb := SET gate_op(gate= middle_river_barrier,device = weir) TO ts(new_time_series) WHERE (vamp AND ebb)</pre><p>This is the form of the operating rule that would be used, say, when parsing a text file rather than using the GUI.</p><h2 id="OperatingRuleGuide-Prediction">Prediction</h2><p>Anticipation using linear or quadratic extrapolation can be added to numerical expressions in expressions using the PREDICT function. What is nice about PREDICT is that it allows trigger expressions to more accurately express the intent of a rule, because you don't need &quot;buffers&quot; which are confusing and inaccurate.</p><p>For instance lets say you want to take some action like close a gate to protect stage in channel 206 in the South Delta from going below zero. If you use a buffer, you write the following:</p><pre>SET [some action] WHEN chan_stage(chan=206, dist=0) &lt;1);</pre><p>This is confusing because the value &quot;1&quot; is used as the trigger criterion when the intent has to do with stage of 0 and not 1. It is inaccurate because it will go off no matter what the trend is. With anticipation, the same rule would look like this:</p><pre>SET [some action] WHEN PREDICT(chan_stage(chan=206, dist=0),LINEAR, 30MIN) &lt; 0;</pre><p>This states the trigger clearly in terms of the value 0. It is also much less likely to go off by accident, because the time trend is used (stage going below 1 is not significant if it is dropping very slowly and not likely to make it to 0). In addition to LINEAR extrapolation quadratic predictions are available using QUAD as the second argument to PREDICT. Over time periods of less than an hour (and not right next to a gate or reservoir), quadratic interpolation is markedly more accurate than linear.</p><h2 id="OperatingRuleGuide-RAMP(transition)">RAMP (transition)</h2><p>For actions, there is also a way to smooth time. The keyword RAMP after an action (together with a number of minutes) will transition in the action gradually, if such a transition makes physical sense.</p><p>For instance, a ramping version of middle_vamp_ebb might use the definition for ebb:</p><pre>SET gate_op( gate=middle_r_barrier, device=radial) TO ts(new_time_series) RAMP 60min</pre><h2 id="OperatingRuleGuide-ComplementaryTriggersandIFELSE">Complementary Triggers and IFELSE</h2><p>Often, an operating rule is paired with a complimentary rule that will reverse its action. For instance, to complement the above rule for ebb flow the following operating rule for flood flow might be added:</p><h3 id="OperatingRuleGuide-Name.1">Name</h3><p>middle_vamp_flood</p><h3 id="OperatingRuleGuide-Expressions.2">Expressions</h3><pre>flood := chan_flow(channel=132, dist=1000) &lt; -0.01<br/>vamp := (month == Apr) or (month == May)</pre><h3 id="OperatingRuleGuide-Trigger.1">Trigger</h3><pre>vamp and flood</pre><h3 id="OperatingRuleGuide-Action.1">Action</h3><pre>SET gate_op( gate=middle_r_barrier, device=barrier,direction=to_node) TO old_time_series</pre><p>This rule effectively undoes the ebb action. The example underscores a necessary but somewhat unintuitive point about triggers: they are one-time and unidirectional. A rule whose trigger is vamp and ebb will activate when this expression changes from false to true but will not do anything or even notice if vamp and ebb subsequently becomes false again. If the complementary behavior is desired, this intent must be specified in a second rule. Often the complementary rule is subtly different from the exact negation of the original; for instance, the trigger vamp and flood is not the same as not(vamp and ebb). In the case of the Montezuma Salinity Control Structure, the flood and ebb triggers are not even based on the same variable (the gate is opened based on a head difference, closed based on velocity).</p><p>The middle_vamp_ebb example combines vamp, which is the seasonal applicability of the rule with ebb, which is a tidal phenomenon. There are also meaningful operating rules that do not need a trigger at all. For instance, the user might want to operate SWP and CVP pumping based on a time series but bound it by some fraction of Sacramento inflow. The trigger in this case is “TRUE” and it will go off once at startup. This is the default in the GUI if you leave the trigger blank.</p><p>If what you really want is a trigger that continuously monitors a true-false condition and applies a value accordingly, you may want to consider using the IFELSE function and no trigger. For instance:</p><pre>SET ext_flow(node=17) TO IFELSE( vamp, ts1, ts2)</pre><p>will set the boundary flow at node 17 (San Joaquin River) to time series ts1 whenever vamp is true and to ts2 when vamp is not true.</p><h2 id="OperatingRuleGuide-MisfiresandRedundantTriggering">Misfires and Redundant Triggering</h2><p>Extra triggering and rule activation may seem harmless when you consider one rule in isolation. Rerunning an action hurts performance, but the action is redundant rather than harmful. The real problem with rules that misfire is that they are active too often and tend to interfere with (“lock out” or “bump”) other rules that are trying to manipulate the same model variable.</p><p>Here is an example of misfiring trigger based on an expression using date terms:</p><pre>(YEAR &gt;= 1990 AND MONTH&gt;=APR AND DAY&gt;=14)</pre><p>(note: a much better way to write this expression using the DATE keyword is given in the reference section)</p><p>Because of the ANDs, this expression requires three conditions to be true at once in order to evaluate to TRUE. It goes off as intended on or about 14APR1990. But what happens on 01MAY1990? On 14MAY1990? This trigger is going to evaluate to FALSE and then back to TRUE. When it makes the FALSE-TRUE transition it will cause the trigger to go off, which is probably not what was intended.</p><p>There is a fix for the above expression (not the recommended on) that illustrates that the only thing that matter are FALSE-TO-TRUE transitions. There is one more curious point about this example is that the correct behavior is obtained using:</p><pre>(YEAR == 1990 AND MONTH == APR AND DAY &gt;= 14)</pre><p>Why? The rule will evaluate FALSE on or about 01MAY1990, but it will stay false!</p><p>These date examples are so common that there is a special way of dealing with them. See the function reference for DATE and SEASON.</p><h2 id="OperatingRuleGuide-Default(TRUE)Trigger">Default (TRUE) Trigger</h2><p>If you leave the trigger definition blank in the GUI the trigger expression will be set to WHEN TRUE.</p><p>The TRUE trigger is roughly equivalent to &quot;at startup&quot; and you should be sure not to confuse it with &quot;always true&quot;. Recall it is transitions that are important, and this trigger makes its only nominal FALSE-TO-TRUE transition once at the very beginning of the run. Once displaced by an overlapping action, the rule will never activate again</p><p>A rule that evaluates to a trivial FALSE will never do anything.</p><p>As an example of a situation where these concepts matter, consider a rule that toggles use of a gate for the entire simulation. By default, a gate in the model is installed. Assume we have set up an expression named use_barriers or remove_barriers indicating whether we want to use gates. Three possibilities for writing the rule are:</p><pre>   TRIGGER                ACTION <br/>1. TRUE                SET gate_install(gate=...) TO use_gate<br/>2. use_gate            SET gate_install(gate...) TO INSTALL<br/>3. remove_gate         SET gate_install(gate=...) TO REMOVE</pre><p>Option 1 uses the default trigger. It will be activated at startup and the gate installation will be set to the expression variable use_gate. Option 2 is interesting because it will never do anything useful. It will be evaluated once at the start of the run, but it will never trigger if use_gate is FALSE. It will trigger if use_gate is TRUE, but this merely carries out the default. Option 3 remedies this by using remove_gate -- the non-default -- as the trigger. Different users seem to regard different options (1) and (3) more intuitive.</p><h2 id="OperatingRuleGuide-Conflicts">Conflicts</h2><p>When a rule is triggered, it will be activated unless it conflicts with another, active rule. Rules conflict when they operate on the same model variable. For instance, two rules that act to change a weir coefficient in the same gate/weir conflict.</p><p>Two specifications govern conflicts:</p><p>1. When a rule conflicts with an active rule it is deferred. Deferred rules are not activated, but they are tricked into thinking they evaluated FALSE so that the can possibly make a FALSE-TRUE transition again the next time step.</p><p>2. When a rule conflicts with another potentially activating rule, the results are “undefined”. We are unaware of any universal solution in this situation. The best solution is to write rules that don’t do this – we are currently working on a better warning system to detect when this happens.</p><h2 id="OperatingRuleGuide-DSM2VariableandFunctionReference:">DSM2 Variable and Function Reference:</h2><h3 id="OperatingRuleGuide-Variables">Variables</h3><p>The variables from DSM2 that can be used in operating rules include boundary and grid variables that can be changed and those that are merely observable (read-only). The observable variables are divided between variables that can be set to time series (Dynamic Variables) that will apply ever-after and variables that can only be set to new static values (Static Variables)</p><h3 id="OperatingRuleGuide-DynamicControlVariables">Dynamic Control Variables</h3><p>These variables are dynamically controllable and can be set to a time series. Once the new time series is set, the boundary or structure being controlled will have no memory of its old controlling time series. Most dynamic variables are gate and boundary data.</p><pre>gate_op(gate=textname,device=textname, direction=[to_node|from_node|to_from_node])</pre><p>Device operating coefficients (0..1) in corresponding direction. Use keywords CLOSE (=0) and OPEN (=1) to make rules more readable. The option &quot;to_from_node&quot; is write-only -- a convenience feature that writes to two otherwise separate variables.</p><pre>gate_position(gate=textname,device=textname)</pre><p>Physical operation of control structure such as radial gate height (physical units). The interpretation of &quot;position&quot; is dependent on the &quot;control_type&quot; of the gate. If it is gated from the bottom, position indicates elevation and is the same as elev. If the control type is gated from the top, as in a radial gate, the position is the height. This variable is deprecated now, in favor of directly using &quot;elev&quot; or &quot;height&quot;.</p><pre>gate_height(gate=textname,device=textname)</pre><p>Height of gate device.</p><pre>gate_elev(gate=textname,device=textname)</pre><p>Crest elevation or invert elevation of gate device.</p><pre>gate_width(gate=textname,device=textname)</pre><p>Width or radius of gate device.</p><pre>ext_flow(name=textname)</pre><p>External flow (boundary flows, source/sink)</p><pre>transfer_flow(transfer=textname)</pre><p>Flows in object-to-object transfers</p><h2 id="OperatingRuleGuide-StaticControlVariables">Static Control Variables</h2><p>These are variables that are normally static. You can set them to a constant. If you set them to a time series, the model will not complain, but the result may not be what you expect. The model variable will only be set to the current value of the series at the time the rule was activated. The variable won't keep changing with the time series.</p><pre>gate_install(gate=textname)</pre><p>Determines or inquires whether the given gate is installed.</p><pre>SET gate_install(...) TO [REMOVE|FALSE]</pre><p>completely removes the gate and restores an equal-stage compatibility condition to the channel junction.</p><pre>SET gate_install(...) TO [INSTALL|TRUE]</pre><p>installs the gate.</p><pre>gate_coef(gate=textname,device=textname,direction=[to_node|from_node])</pre><p>Gate coefficient of the device in the given direction. This is a physical quantitity of the structure, representing the roughness or efficiency of flow. It should not be used for operating controls such as flap gates. The coefficients will change only rarely when the actual site is altered and should never leave the range (0,1).</p><pre>gate_nduplicate(gate=textname,device=textname)</pre><p>Number of duplicate devices.</p><h2 id="OperatingRuleGuide-ObservableVariables">Observable Variables</h2><p>These are read-only model variables that cannot be manipulated directly, but can be observed and used in expressions for triggers and actions.</p><pre>chan_flow(channel=number,dist=[number|length])</pre><p>Flow in channel.dist=length indicates the end of the channel.</p><pre>chan_vel(channel=number, dist=[number|length])</pre><p>Velocity at given channel and distance.</p><pre>chan_stage(channel=number,dist=[number|length])</pre><p>Water Surface at given channel and distance.</p><pre>chan_surf</pre><p>Same as stage (water surface) in channel</p><pre>res_stage(res=textname)</pre><p>Water surface in reservoir</p><pre>res_flow(res=textname, node=number)</pre><p>Flow from reservoir to node</p><pre>ts(name=textname)</pre><p>Any time series named in the Operating Rule View of the GUI may be used by referencing the name. Time series evaluate to their value at the current time step.</p><h2 id="OperatingRuleGuide-ModelTimeQueries">Model Time Queries</h2><p>The following commands retrieve model date or seasonal information:</p><pre>YEAR, MONTH, DAY</pre><p>Retrieves the year, month and day associated with the current model time step. These are returned as numbers. When testing them, you can (for clarity) use 3-letter abbreviations for the months. Examples:</p><pre>YEAR &gt;= 1991</pre><pre>MONTH + 1 &lt; MAY</pre><pre>HOUR, MIN</pre><p>Retrieve the (24 hour) hour and minute associated with the current model time step.</p><pre>DATE</pre><p>Returns a time stamp corresponding to the beginning of the day on the current model date. Example:</p><pre>DATE &gt;= 11OCT1992 (not time part)</pre><pre>DT</pre><p>Represents the model time step in seconds. This is often useful for use with ACCUMULATE</p><pre>DATETIME</pre><p>Returns a time stamp corresponding to the current model date and time. Example:</p><pre>DATETIME &gt; 04FEB1990 00:00 (date plus time)</pre><pre>SEASON</pre><p>Returns a time stamp relative to the beginning of the year corresponding to the beginning of the day on the current model date and time. Comparisons such as SEASON &gt; 15APR AND SEASON &lt;01MAY avoid common logical mistakes from building this from scratch.<br/>There is one other gotcha with SEASON that comes up at the end of time periods because the timestamp is always at 00:00. Compare SEASON &gt; 15APR AND SEASON &lt;01MAY SEASON &gt; 15APR AND SEASON ≤30APR and notice that the latter does not include the entire day 30APR.</p><p>Note SEASON and DATE/DATETIME to combined expressions built from atomic expressions like day and month. They are clearer and avoid some curious gotchas. For instance DATE &gt;= 14APR1990 will evaluate true only once per year, whereas (YEAR &gt;= 1990 AND MONTH&gt;=APR AND DAY&gt;=14) will evaluate true on Apr 14, false on May 1 and true again on May 14. You could get the intended behavior with (YEAR == 1990 AND MONTH == APR AND DAY&gt;=14), which will go from false to true only once, but the fix hardly seems worth the trouble.</p><h2 id="OperatingRuleGuide-NumericalOperations">Numerical Operations</h2><p>The following operators and functions are available</p><pre>+, -, *, /</pre><p>Arithmetic operators with standard precedence of operations. You can use parenthesis to change the evaluation order.</p><pre>x^3, x^y</pre><p>Power of x and x to the power of y</p><pre>MIN2(x,y)</pre><p>Minimum of two arguments.</p><pre>MAX2(x,y)</pre><p>Maximum of two arguments.</p><pre>MIN3(x,y,z)</pre><p>Minimum of three arguments.</p><pre>MAX3(x,y,z)</pre><p>Maximum of three arguments.</p><pre>SQRT(x)</pre><p>Square root of x</p><pre>EXP(x)</pre><p>Exponent function (e to the power of x)</p><pre>LN(x)</pre><p>Natural log of x</p><pre>LOG(x)</pre><p>Base 10 log of x</p><h2 id="OperatingRuleGuide-LogicalOperations">Logical Operations</h2><pre>x==y</pre><p>Tests equality.</p><pre>x&lt;&gt;y</pre><p>Tests inequality.</p><pre>x&lt;y,x&gt;y, x&lt;=y, x&gt;=y</pre><p>Comparisons.</p><pre>TRUE</pre><p>The value TRUE</p><pre>FALSE</pre><p>The value FALSE</p><pre>NOT expression</pre><p>Negation of expression, as in NOT(x &lt; y)</p><pre>expr1 AND expr2</pre><p>Logical ‘and’, which evaluates to TRUE only if both the expressions it joins are true. Expression (expr2) will not be evaluated if expr1 evaluates to FALSE.</p><pre>expr1 OR expr2</pre><p>Logical ‘or’</p><h2 id="OperatingRuleGuide-SpecialFunctions">Special Functions</h2><pre>ACCUMULATE(expression, initval [,resetcond])</pre><p>Cumulative value function. Accumulates additively the value of expression using initval (another numerical expression) as the initial condition and resetting the total anytime the resetcond evaluates to true. If you want to integrate you should multiply the expression by DT or else your rule won't be robust if someone changes the time step.</p><pre>IFELSE(boolexpr, valexp1,valexpr2)</pre><p>The ternary operator. If boolexpr returns true, returns the value given by valexpr1. If boolexpr returns false, returns the value given by valexpr2.</p><pre>LOOKUP(expression, lookup_array,value_array)</pre><p>Lookup values from a small user supplied table. The lookup array is provided using a bracketed, comma-separated list of values such as [1000.,2000.,3000.]. The value_array return values are similar but must have a length one smaller than the number of lookup values. The array values must be hard-wired numbers at the present time -- expressions are not allowed. The LOOKUP compares expression to elements of lookup_array. The highest element of the lookup table is currently a limit, not an actual lookup slot. The function returns the component of value_array corresponding to the highest index in lookup array that is &lt;= expression, e.g.:</p><pre>LOOKUP(1000.,[1000.,2000.,3000.], [1.,2.]) returns 1.</pre><pre>LOOKUP(2000.,[1000.,2000.,3000.], [1.,2.]) returns 2.</pre><pre>LOOKUP(3000.,[1000.,2000.,3000.], [1.,2.]) is an error.</pre><pre>PID( PID(expression,target,low,high,K, Ti,Td,Tt,b)</pre><p>Use PID (Proportional, Integral, Derivative) control to try to guide expression towards target. The parameters are as follows<br/>low: lower bound on control representing the minimum value the control value can take (e.g. for gate height this might be zero).</p><p>high: upper bound on control.</p><p>K: The constant representing the Proportion component of the control. The constant multiplies (expression-target) to change a control value, so choose a factor that is reasonable that takes the scaling of the expression to the scaling of the control.</p><p>Ti: Integral time constant of control</p><p>Td: Derivative time constant of control.</p><p>Tt: Time basis of &quot;anti-windup&quot;</p><p>b: Set-point weighting (use 1.0 if you are new to PID).</p><p><div style="page-break-before:always;" /></p>
                    </div>

                                        
                                                      
                </div>             </div> 
            <div id="footer" role="contentinfo">
                <section class="footer-body">
                    <p>Document generated by Confluence on May 16, 2023 11:04</p>
                    <div id="footer-logo"><a href="http://www.atlassian.com/">Atlassian</a></div>
                </section>
            </div>
        </div>     </body>
</html>
